; This function calculates power both for the current game and for the selected user profile
; The calculation considers score, soft-drop points, lines, previous power, and number of games played previously.
; ROM5 6E97 to 6FDE
label6E97:
ld   a,(C119)       ; TODO: Analysis of 6E97 to 6EB9
and  a
ret  z
ld   hl,BFF0
ld   de,AC24
ld   a,(AC09)
and  a,0F
add  a
add  a
add  l
ld   l,a
ld   a,(de)
add  (hl)
ld   (hl),a
inc  e
ld   a,(de)
adc  (hl)
ldi  (hl),a
ld   b,00
ld   a,(hl)
adc  b
ldi  (hl),a
ld   a,(hl)
adc  b
ld   (hl),a
ld   hl,AC26        ; Load score (S) pointer into HL
ld   de,AFB2        ; Load soft-drop points (SD) pointer into DE
ld   b,00           ; This section subtracts SD (excluding the lowest nybble) from S, resulting in a value of S - SD + (SD % 16)
ld   a,(de)         ; Load lower byte of SD into A
and  a,F0           ; Discard lower nybble of SD
ld   c,a            ; Load A into C
ld   a,(hl)         ; Load lowest byte of S into A
sub  c              ; Subtract C from A
ldi  (hl),a         ; Replace S in SRAM with A, then increment HL to AC27 (next byte of S)
inc  e              ; Increment E, so DE now contains AFB3 (upper byte of SD)
ld   a,(de)         ; Load upper byte of SD into A
ld   c,a
ld   a,(hl)         ; Load second byte of S into A
sbc  c              ; If subtracting the first byte overflowed A and set the carry flag, subtract 1 when subtracting C from A here
ldi  (hl),a         ; Replace second byte of S in SRAM with A, then increment HL to AC28
inc  e              ; AFB4 is not used here
ld   a,(hl)         ; Load third byte of S into A
sbc  b              ; Since B was initialised to 00 earlier, this just subtracts the carry flag from A if it is set
ldi  (hl),a         ; Replace third byte of S in SRAM with A, then increment HL to AC29
ld   a,(hl)         ; Load highest byte of S into A
sbc  b
ld   (hl),a         ; Replace highest byte of S in SRAM with A
ld   hl,AC24        ; Load lines (L) pointer into HL
ld   a,(AC26)       ; Load all bytes of S into registers BCDE
ld   e,a
ld   a,(AC27)
ld   d,a
ld   a,(AC28)
ld   c,a
ld   a,(AC29)
ld   b,a
call 0637           ; See helper_functions/0637_divide - This divides the score by the number of lines and puts the result in DE
ld   hl,AC25        ; TODO: Tidy up rest of analysis in this file
ldd  a,(hl)
and  a
jr   nz,label6F25
ld   a,(hl)
and  a
jr   z,label6F22
cp   a,0B
jr   c,label6F18
cp   a,10
jr   c,label6F1C
cp   a,15
jr   nc,label6F25
ld   h,d
ld   l,e
srl  h
rr   l
srl  h
rr   l
ld   a,e
sub  l
ld   e,a
jr   nc,label6F13
dec  d
label6F13:
ld   a,d
sub  h
ld   d,a
jr   label6F25
label6F18:
srl  d
rr   e
label6F1C:
srl  d
rr   e
jr   label6F25
label6F22:
ld   de,0000
label6F25:
ld   a,d
ld   (DB61),a
ld   a,e
ld   (DB60),a
xor  a
ld   (DB68),a
ld   (DB69),a
ld   a,(AC09)
and  a,0F
call label7029
xor  a
ldi  (hl),a
ld   a,(hl)
ld   (DB68),a
cp   a,05
jr   nc,label6F47
inc  a
label6F47:
ldi  (hl),a
push hl
ld   a,l
and  a,80
add  a,58
ld   l,a
add  a,14
ld   d,h
ld   e,a
ld   c,50
label6F55:
ldd  a,(hl)
ld   (de),a
dec  e
dec  c
jr   nz,label6F55
ld   a,(AC0A)
cp   a,02
jr   nz,label6F83
ld   a,(DB61)       ; This section will only run if the current mode is Sprint
ld   d,a            ; TODO: Analyse 6F62-6F80
ld   a,(DB60)
ld   e,a
push de
ld   hl,AC24
ldi  a,(hl)
ld   e,a
ld   d,(hl)
call label7060      ; TODO: Analyse 7060 helper function
ld   a,(DB64)
ld   (AF8D),a
pop  de
ld   a,d
ld   (DB61),a
ld   a,e
ld   (DB60),a
label6F83:
pop  hl
push hl
ld   d,h
ld   e,l
ld   hl,AF8D
ld   c,03
call label7055
pop  hl
inc  l
inc  l
inc  l
inc  l
push hl
ldi  a,(hl)
ld   d,(hl)
ld   e,a
ld   hl,0000
ld   a,(DB68)
and  a
jr   z,label6FA5
label6FA1:
add  hl,de
dec  a
jr   nz,label6FA1
label6FA5:
ld   a,(DB61)
ld   d,a
ld   a,(DB60)
ld   e,a
add  hl,de
ld   bc,0000
ld   d,h
ld   e,l
ld   hl,DB68
inc  (hl)
call 0637
pop  hl             ; TODO: Analyse 6FBA to end of function
ld   (hl),e
inc  l
ld   (hl),d
inc  l
ld   de,AC10
ld   c,14
label6FC4:
ld   a,(de)
ldi  (hl),a
inc  e
dec  c
jr   nz,label6FC4
ld   a,l
and  a,80
add  a,7F
ld   l,a
xor  a
ld   c,7E
label6FD3:
add  (hl)
dec  l
dec  c
jr   nz,label6FD3
ld   b,a
ld   a,CB
ldd  (hl),a
add  b
ld   (hl),a
ret  

; Check lines
6EEC - Load AC25 pointer into HL
6EEF - Load value from AC25 (via HL) into A and decrement HL to AC24
6EF0 - AND A with itself
6EF1 - Jump to 6F25 if z is false

; 6EF0 will set z to true and run this section if A (i.e. lines / 256) is 0
6EF3 - Load value of AC24 into A
6EF4 - AND A with itself
6EF5 - Jump to 6F25 if z is true

; 6EF5 will set z to true and SKIP this section if A (i.e. lines % 256) is 0
; This section will only run if cleared lines is between 1 and 255
6EF7 - Set c to true if A is less than OB
6EF9 - Jump to 6F18 if c is true
6EFB - Set c to true if A is less than 10
6EFD - Jump to 6F1C if c is true
6EFF - Set c to true if A is less than 15
6F01 - Jump to 6F25 is c is false

; This section will only run if cleared lines is between 16 and 20
6F03 - Load value of D into H
6F04 - Load value of E into L
6F05 - Bit-shift H to the right
6F07 - Bit-shift L to the right, including c
6F09 - Bit-shift H to the right
6F0B - Bit-shift L to the right, including c
6F0D - Load value of E into A
6F0E - Subtract value of L from A
6F0F - Load value of A into E
6F10 - Jump to 6F13 if c is false

; This will only run if L is greater than E
; I have no idea why it does this
6F12 - Decrement D

; Effectively reduce power in DE by a quarter
6F13 - Load value of D into A
6F14 - Subtract value of H from A
6F15 - Load value of A into D
6F16 - Jump to 6F25

; This section will only run if cleared lines is between 1 and 10
6F18 - Bit-shift D to the right
6F1A - Bit-shift E to the right, including c

; This section will only run if cleared lines is between 1 and 15
6F1C - Bit-shift D to the right
6F1E - Bit-shift E to the right, including c
6F20 - Jump to 6F25

; I don't think this is hit, unless something else jumps here
6F22 - Set DE to 0000

; Store DE (Current Game Power) in memory
6F25 - Load value of D into A
6F26 - Load value of A into DB61
6F29 - Load value of E into A
6F2A - Load value of A into DB60

; Clear DB68 and DB69
6F2D - XOR A with itself, clearing it
6F2E - Load value of A into DB68
6F31 - Load value of A into DB69

; Load selected user profile
6F34 - Load value of AC09 into A
6F37 - AND A with value 0F
6F39 - Call function 7029

; From this point forward, I will be using Profile 1 SRAM addresses for descriptions
; Clear BC81 and copy BC82 (games played) into DB68
; The stored number of games played is capped at 5
6F3C - XOR A with itself
6F3D - Load value of A into BC81 (via HL), increment HL to BC82
6F3E - Load value of BC82 (via HL) into A
6F3F - Load value of A into DB68
6F42 - Set c to true if A is less than 5
6F44 - Jump to 6F47 if c is false
; This is only called if games played is less than 5
6F46 - Increment A
6F47 - Load value of A into BC82, increment HL to BC83
6F48 - Push HL onto stack

; This basically sets L to either 00 or 80, making HL the beginning of the current profile section in SRAM (BC80 in this case)
6F49 - Load value of L into A
6F4A - AND A with constant value 80

; Set HL to BCD8
6F4C - Add 58 to A
6F4E - Load value of A into L

; Set DE to BCEC
6F4F - Add 14 to A
6F51 - Load value of H into D
6F52 - Load value of A into E

; This is a loop which runs 80 (hex 50) times
; It copies SRAM addresses BC88-BCD8 into BC9C-BCEC, shifting this section forward by 20 (hex 14) and duplicating BC88-BC9B with BC9C-BCB0
6F53 - Load constant value 50 into C
6F55 - Load value of value pointed by HL into A, decrement HL
6F56 - Load value of A into address pointed by DE
6F57 - Decrement E
6F58 - Decrement C
6F59 - Jump to 6F55 if z is false

; Determine whether current mode is Sprint
6F5B - Load value of AC0A into A
; Set zero flag if A is 02
6F5E - Compare A with constant value 02
6F60 - Jump to 6F83 if z is false

; This will run for all modes
; Set DE to BC83 (total profile lines) and HL to AF8D (lines for current game)
6F83 - Pop stack into HL (address BC83)
6F84 - Push HL into stack
6F85 - Load value of H into D
6F86 - Load value of L into E
6F87 - Load constant value AF8D into HL
6F8A - Load constant value 03 into C
6F8C - Call function 7055

; This function contains a loop after the XOR, run 3 times
; Adds AF8D-AF8F to BC83-BC85 as decimal values
; In other words, adds the lines from your current game to your profile total
7055 - XOR A with itself
7056 - Load value pointed by DE into A
7057 - Add value pointed by HL + c to A
; This DAA means treat the addition as BCD, not hex
7058 - Decimal Adjust Accumulator
7059 - Load value of A into address pointed by DE
705A - Increment E
705B - Increment L
705C - Decrement C
705D - Jump to 7056 if z is false
705F - Return from function

; Set HL to Profile Power
6F8F - Pop stack into HL (address BC83)
6F90-6F93 - Increment L
; HL now contains BC87
6F94 - Push HL into stack
6F95 - Load value of BC87 (via HL) into A, increment HL to BC88
6F96 - Load value of BC88 (via HL) into D
6F97 - Load value of A into E
6F98 - Load constant value 0000 into HL
6F9B - Load value of DB68 into A
; This AND sets z if A is 00
6F9E - AND A with itself
6F9F - Jump to 6FA5 if z is true

; This section will only run if number of games played is non-zero
; This is a loop which multiplies Profile Power by games played and assigns it to HL
6FA1 - Add DE to HL
6FA2 - Decrement A
6FA3 - Jump to 6FA1 if z is false

; Set DE to Current Game Power, then add to HL (Profile Power)
6FA5 - Load value of DB61 into A
6FA8 - Load value of A into D
6FA9 - Load value of DB60 into A
6FAC - Load value of A into E
6FAD - Add HL to DE

; Move value of HL into DE
6FAE - Load constant value 0000 into BC
6FB1 - Load value of H into D
6FB2 - Load value of L into E

; Increment DB68, then call bitshift loop again
; Calculates new Profile Power based on (Pc + Pp * N) / (N + 1)
; Where Pc is Current Game Power, Pp is previous Profile Power, and N is Games Played (Max 5)
6FB3 - Load constant value DB68 into HL
6FB6 - Increment value of DB68 (via HL)
6FB7 - Call function 0637
